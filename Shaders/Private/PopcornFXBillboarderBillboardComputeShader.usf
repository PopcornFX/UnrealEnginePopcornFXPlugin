//----------------------------------------------------------------------------
// Copyright Persistant Studios, SARL. All Rights Reserved.
// https://www.popcornfx.com/terms-and-conditions/
//----------------------------------------------------------------------------

/*=============================================================================
PopcornFXBillboarderBillboardComputeShader.usf: Billboard renderer compute shader billboarder
=============================================================================*/

#include "/Engine/Public/Platform.ush"

#if COMPILER_HLSL

#define NORMALIZER_EPSILON	1.0e-8f

RWByteAddressBuffer		OutIndicesRaw;
RWBuffer<uint>			OutIndices;

RWByteAddressBuffer		OutPositions;
RWByteAddressBuffer		OutTexcoords;
RWByteAddressBuffer		OutTexcoord2s;
RWByteAddressBuffer		OutAtlasIDs;
RWByteAddressBuffer		OutNormals;
RWByteAddressBuffer		OutTangents;

ByteAddressBuffer		InIndices;
ByteAddressBuffer		InSimData;

uint		InPositionsOffset;
uint		InSizesOffset;
uint		In2SizesOffset;
uint		InRotationsOffset;
uint		InAxis0sOffset;
uint		InAxis1sOffset;
uint		InTextureIdsOffset;

float4		DefaultInPositions;
float4		DefaultInSizes;
float4		DefaultIn2Sizes;
float4		DefaultInRotations;
float4		DefaultInAxis0s;
float4		DefaultInAxis1s;
float4		DefaultInTextureIds;

uint		BillboarderType;
uint		OutputMask;
uint		InputMask;
uint		InIndicesOffset;
uint		InputOffset;
uint		OutputVertexOffset;
uint		OutputIndexOffset;

float4x4	BillboardingMatrix;

uint		RendererFlags;
float		RendererNormalsBendingFactor;

uint					HasLiveParticleCount;
ByteAddressBuffer		LiveParticleCount;

uint					RendererAtlasRectCount;
ByteAddressBuffer		RendererAtlasBuffer;
//Buffer<uint>			RendererAtlasBuffer;

// RightHanded:
//#define		myCross(a, b)		cross(a, b)
// LeftHanded:
#define		myCross(a, b)		cross(b, a)

#define		swapf(x, y)		x = asfloat(asuint(x) ^ asuint(y)); y = asfloat(asuint(y) ^ asuint(x)); x = asfloat(asuint(x) ^ asuint(y));
#define		swapi(x, y)		x = x ^ y; y = y ^ x; x = x ^ y;

#define		FLOAT2_TO_USHORTUNORM2(__x, __y)	(asuint(clamp((int)(__x * 65535.0), 0, 0xFFFF)) | (asuint(clamp((int)(__y * 65535.0), 0, 0xFFFF)) << 16))
uint		Float2ToUshortUnorm2(float2 tc) { return FLOAT2_TO_USHORTUNORM2(tc.x, tc.y); }

[numthreads(PK_GPU_THREADGROUP_SIZE, 1, 1)]
void		Billboard(uint3 DTid : SV_DispatchThreadID)
{
	const uint		globali = DTid.x;
	const uint		inputi = InputOffset + globali;

	if (HasLiveParticleCount != 0)
	{
		const uint		particleCount = asint(LiveParticleCount.Load(0));
		if (inputi < particleCount)
		{
			const float3	center = asfloat(InSimData.Load3(InPositionsOffset + inputi * 12));

			float2			radius;
			if (InputMask & MASK_InSizes)
				radius = (float2)asfloat(InSimData.Load(InSizesOffset + inputi * 4));
			else if (InputMask & MASK_In2Sizes)
				radius = asfloat(InSimData.Load2(In2SizesOffset + inputi * 8));
			else
				radius = (float2)DefaultInSizes.x;

			float3			xAxis;
			float3			yAxis;
			float3			capsuleUpVec = float3(0, 0, 1);

			switch (BillboarderType)
			{
			case BILLBOARD_ScreenAligned:
			{
				xAxis = BillboardingMatrix[0].xyz * radius.x;
				yAxis = BillboardingMatrix[1].xyz * radius.y;
			}
			break;
			case BILLBOARD_ViewposAligned:
			{
				const float3	viewPos = BillboardingMatrix[3].xyz;
				const float3	camToParticle = normalize(center - viewPos);
				// Z Up:
				const float3	upAxis = float3(0, camToParticle.z * 0.01f, 1);
				// Y Up:
				//float4		upAxis = float3(0, 1, camToParticle.y * 0.01);
				xAxis = normalize(myCross(camToParticle, upAxis));
				yAxis = myCross(xAxis, camToParticle) * radius.y;
				xAxis *= radius.x;
			}
			break;
			case BILLBOARD_AxisAligned:
			{
				const float3	viewPos = BillboardingMatrix[3].xyz;
				const float3	camToParticle = center - viewPos;
				const float3	axis = asfloat(InSimData.Load3(InAxis0sOffset + inputi * 12));

				xAxis = myCross(camToParticle, axis);
				if (dot(xAxis, xAxis) > NORMALIZER_EPSILON)
					xAxis = normalize(xAxis);
				else
				{
					const float3	v = float3(-camToParticle.y, camToParticle.x + 0.01f, 0.0f);
					xAxis = normalize(myCross(camToParticle, v));
				}
				xAxis *= radius.x;

				yAxis = axis * 0.5f;
			}
			break;
			case BILLBOARD_AxisAlignedCapsule:
			{
				const float3	viewPos = BillboardingMatrix[3].xyz;
				const float3	camToParticle = normalize(center - viewPos);
				const float3	axis = asfloat(InSimData.Load3(InAxis0sOffset + inputi * 12));

				float3	sideVec = myCross(camToParticle, axis);
				if (dot(sideVec, sideVec) > NORMALIZER_EPSILON)
					sideVec = normalize(sideVec);
				else
				{
					const float3	v = float3(-camToParticle.y, camToParticle.x + 0.01f, 0.0f);
					sideVec = normalize(myCross(camToParticle, v));
				}
				sideVec *= radius.x;

				const float3	upVec = myCross(sideVec, camToParticle);
				xAxis = sideVec;
				yAxis = axis * 0.5f;
				capsuleUpVec = upVec;
			}
			break;
			case BILLBOARD_AxisAlignedSpheroid:
			{
				const float3	viewPos = BillboardingMatrix[3].xyz;
				const float3	camToParticle = normalize(center - viewPos);
				const float3	axis = asfloat(InSimData.Load3(InAxis0sOffset + inputi * 12));

				float3	sideVec = myCross(camToParticle, axis);
				if (dot(sideVec, sideVec) > NORMALIZER_EPSILON)
					sideVec = normalize(sideVec);
				else
				{
					const float3	v = float3(-camToParticle.y, camToParticle.x + 0.01f, 0.0f);
					sideVec = normalize(myCross(camToParticle, v));
				}
				sideVec *= radius.x;

				const float3	upVec = myCross(sideVec, camToParticle);
				xAxis = sideVec;
				yAxis = axis * 0.5f + upVec;
			}
			break;
			case BILLBOARD_PlaneAligned:
			{
				const float3	axis_fwd = asfloat(InSimData.Load3(InAxis0sOffset + inputi * 12));
				const float3	axis_nrm = asfloat(InSimData.Load3(InAxis1sOffset + inputi * 12));

				xAxis = myCross(axis_fwd, axis_nrm);
				if (dot(xAxis, xAxis) > NORMALIZER_EPSILON)
					xAxis = normalize(xAxis);
				else
				{
					const float3	v = float3(-axis_nrm.y, axis_nrm.x + 0.01f, 0.0f);
					xAxis = normalize(myCross(v, axis_nrm));
				}

				yAxis = myCross(axis_nrm, xAxis);
				const float2	scale = radius * 0.5f;
				xAxis *= scale.x;
				yAxis *= scale.y;
			}
			break;
			}

			if (InputMask & MASK_InRotations)
			{
				const float		a = asfloat(InSimData.Load(InRotationsOffset + inputi * 4));
				const float		c = cos(a);
				const float		s = sin(a);
				const float3	xa = xAxis;
				xAxis = yAxis * s + xAxis * c;
				yAxis = yAxis * c - xa * s;
			}

			const float3	xpy = xAxis + yAxis;
			const float3	xmy = xAxis - yAxis;
			const float3	v0 = center - xpy;
			const float3	v1 = center + xmy;
			const float3	v2 = center + xpy;
			const float3	v3 = center - xmy;

			const uint		vpp = ((BillboarderType == BILLBOARD_AxisAlignedCapsule) ? 6 : 4);
			const bool		is6vert = (vpp == 6);
			const uint		vstart = globali * vpp + OutputVertexOffset;


			// NOTE: Performance might benefit quite a bit from outputting packed float3 vertices
			if (OutputMask & MASK_OutPositions)
			{
				
#if PK_BILLBOARDER_CS_OUTPUT_PACK_PTN
				const uint	addr = vstart * 12;
				OutPositions.Store3(addr + 0 * 12, asint(v0));
				OutPositions.Store3(addr + 1 * 12, asint(v1));
				OutPositions.Store3(addr + 2 * 12, asint(v2));
				OutPositions.Store3(addr + 3 * 12, asint(v3));
				if (is6vert)
				{
					const float3		v4 = center + yAxis + capsuleUpVec;
					const float3		v5 = center - yAxis - capsuleUpVec;
					OutPositions.Store3(addr + 4 * 12, asint(v4));
					OutPositions.Store3(addr + 5 * 12, asint(v5));
				}
#else
				const uint		addr = vstart * 16;
				OutPositions.Store4(addr + 0 * 16, asint(float4(v0, 0)));
				OutPositions.Store4(addr + 1 * 16, asint(float4(v1, 0)));
				OutPositions.Store4(addr + 2 * 16, asint(float4(v2, 0)));
				OutPositions.Store4(addr + 3 * 16, asint(float4(v3, 0)));
				if (is6vert)
				{
					const float3		v4 = center + yAxis + capsuleUpVec;
					const float3		v5 = center - yAxis - capsuleUpVec;
					OutPositions.Store4(addr + 4 * 16, asint(float4(v4, 0)));
					OutPositions.Store4(addr + 5 * 16, asint(float4(v5, 0)));
				}
#endif

			}

			// @TODO early out
			//if ((OutputMask & (
			//
			//)) == 0)
			//	return

			if (OutputMask & MASK_OutNormals)
			{
				float3			normal0;
				float3			normal1;
				float3			normal2;
				float3			normal3;

				float3			xAxisNorm;
				float3			yAxisNorm;
				if (RendererNormalsBendingFactor > 0)
				{
					xAxisNorm = normalize(xAxis);
					yAxisNorm = normalize(yAxis);

					const float3	baseNormal = myCross(xAxisNorm, yAxisNorm); // already ortho
					const float3	nw = baseNormal * (1.0f - RendererNormalsBendingFactor);

					const float3	xpy = (xAxisNorm + yAxisNorm) * RendererNormalsBendingFactor;
					const float3	xmy = (xAxisNorm - yAxisNorm) * RendererNormalsBendingFactor;
					normal0 = nw - xpy;
					const float3	rlen = 1.0f / length(normal0);
					normal0 *= rlen;
					normal1 = (nw + xmy) * rlen;
					normal2 = (nw + xpy) * rlen;
					normal3 = (nw - xmy) * rlen;
				}
				else
				{
					const float3	baseNormal = normalize(myCross(xAxis, yAxis));
					normal0 = baseNormal;
					normal1 = baseNormal;
					normal2 = baseNormal;
					normal3 = baseNormal;
				}

#if PK_BILLBOARDER_CS_OUTPUT_PACK_PTN
				// normals
				{
					const uint		addr = vstart * 12;
					OutNormals.Store3(addr + 0 * 12, asint(normal0));
					OutNormals.Store3(addr + 1 * 12, asint(normal1));
					OutNormals.Store3(addr + 2 * 12, asint(normal2));
					OutNormals.Store3(addr + 3 * 12, asint(normal3));
					if (is6vert)
					{
						const float3		normal4 = normal2; // @TODO fixme ?
						const float3		normal5 = normal0;
						OutNormals.Store3(addr + 4 * 12, asint(normal4));
						OutNormals.Store3(addr + 5 * 12, asint(normal5));
					}
				}
				// no tangent without normals anyway
				if (OutputMask & MASK_OutTangents)
				{
					const uint		addr = vstart * 12;
					//const float3	tangent = RendererNormalsBendingFactor > 0 ? xAxisNorm : normalize(xAxis);
					const float3	tangent = normalize(xAxis);

					OutTangents.Store3(addr + 0 * 12, asint(tangent));
					OutTangents.Store3(addr + 1 * 12, asint(tangent));
					OutTangents.Store3(addr + 2 * 12, asint(tangent));
					OutTangents.Store3(addr + 3 * 12, asint(tangent));
					if (is6vert)
					{
						OutTangents.Store3(addr + 4 * 12, asint(tangent));
						OutTangents.Store3(addr + 5 * 12, asint(tangent));
					}
				}
#else
				// normals
				{
					const uint		addr = vstart * 16;
					OutNormals.Store4(addr + 0 * 16, asint(float4(normal0, 0)));
					OutNormals.Store4(addr + 1 * 16, asint(float4(normal1, 0)));
					OutNormals.Store4(addr + 2 * 16, asint(float4(normal2, 0)));
					OutNormals.Store4(addr + 3 * 16, asint(float4(normal3, 0)));
					if (is6vert)
					{
						const float3		normal4 = normal2; // @TODO fixme ?
						const float3		normal5 = normal0;
						OutNormals.Store4(addr + 4 * 16, asint(float4(normal4, 0)));
						OutNormals.Store4(addr + 5 * 16, asint(float4(normal5, 0)));
					}
				}
				// no tangent without normals anyway
				if (OutputMask & MASK_OutTangents)
				{
					const uint		addr = vstart * 16;
					//const float3	tangent = RendererNormalsBendingFactor > 0 ? xAxisNorm : normalize(xAxis);
					const float3	tangent = normalize(xAxis);

					OutTangents.Store4(addr + 0 * 16, asint(float4(tangent, 0)));
					OutTangents.Store4(addr + 1 * 16, asint(float4(tangent, 0)));
					OutTangents.Store4(addr + 2 * 16, asint(float4(tangent, 0)));
					OutTangents.Store4(addr + 3 * 16, asint(float4(tangent, 0)));
					if (is6vert)
					{
						OutTangents.Store4(addr + 4 * 16, asint(float4(tangent, 0)));
						OutTangents.Store4(addr + 5 * 16, asint(float4(tangent, 0)));
					}
				}
#endif
			}

			if (OutputMask & MASK_OutTexcoords)
			{
#if PK_BILLBOARDER_CS_OUTPUT_PACK_TEXCOORD
#	define tc_t				uint
#	define tc_Store			Store
#	define tc_Stride		4
#	define tc_swap(a, b)	swapi(a, b)
#	define TC_PACK(a, b)	FLOAT2_TO_USHORTUNORM2(a, b)
#	define tc_pack(a)		Float2ToUshortUnorm2(a)
#else
#	define tc_t				float2
#	define tc_Store			Store2
#	define tc_Stride		8
#	define tc_swap(a, b)	swapf(a, b)
#	define TC_PACK(a, b)	float2(a, b)
#	define tc_pack(a)		a
#endif
				tc_t	uv00;
				tc_t	uv01;
				tc_t	uv11;
				tc_t	uv10;
				tc_t	uv00_2;
				tc_t	uv01_2;
				tc_t	uv11_2;
				tc_t	uv10_2;
				float	softAnimBlend = 0;

				if (InputMask & MASK_InTextureIds)
				{
					const float		atlasIdf = asfloat(InSimData.Load(InTextureIdsOffset + inputi * 4));
					const uint		atlasId0 = min((uint)abs(atlasIdf), RendererAtlasRectCount - 1);

					const float4	rect0 = asfloat(RendererAtlasBuffer.Load4(atlasId0 * 4 * 4));
					//const float4	rect0 = asfloat(RendererAtlasBuffer[atlasId0 * 4]);

					uv00 = tc_pack(float2(0, 0) * rect0.xy + rect0.zw);
					uv01 = tc_pack(float2(0, 1) * rect0.xy + rect0.zw);
					uv10 = tc_pack(float2(1, 0) * rect0.xy + rect0.zw);
					uv11 = tc_pack(float2(1, 1) * rect0.xy + rect0.zw);

					if (RendererFlags & RENDERERFLAG_SoftAnimationBlending) // should be true too: (OutputMask & MASK_OutTexcoord2s)
					{
						const uint		atlasId1 = min(atlasId0 + 1, RendererAtlasRectCount - 1);
						const float4	rect1 = asfloat(RendererAtlasBuffer.Load4(atlasId1 * 4 * 4));
						//const float4	rect1 = asfloat(RendererAtlasBuffer[atlasId1 * 4]);

						uv00_2 = tc_pack(float2(0, 0) * rect1.xy + rect1.zw);
						uv01_2 = tc_pack(float2(0, 1) * rect1.xy + rect1.zw);
						uv10_2 = tc_pack(float2(1, 0) * rect1.xy + rect1.zw);
						uv11_2 = tc_pack(float2(1, 1) * rect1.xy + rect1.zw);

						// MASK_OutAtlasIDs should be active too
						softAnimBlend = frac(atlasIdf);
					}
				}
				else
				{
					uv00 = TC_PACK(0, 0);
					uv01 = TC_PACK(0, 1);
					uv11 = TC_PACK(1, 1);
					uv10 = TC_PACK(1, 0);
					uv00_2 = TC_PACK(0, 0);
					uv01_2 = TC_PACK(0, 1);
					uv11_2 = TC_PACK(1, 1);
					uv10_2 = TC_PACK(1, 0);
				}

				if (RendererFlags & RENDERERFLAG_FlipV)
				{
					tc_swap(uv01, uv00);
					tc_swap(uv11, uv10);
					tc_swap(uv01_2, uv00_2);
					tc_swap(uv11_2, uv10_2);
				}

				// Texcoord
				{
					const uint		addr = vstart * tc_Stride;
					if (!is6vert)
					{
						OutTexcoords.tc_Store(addr + 0 * tc_Stride, asint(uv01));
						OutTexcoords.tc_Store(addr + 1 * tc_Stride, asint(uv11));
						OutTexcoords.tc_Store(addr + 2 * tc_Stride, asint(uv10));
						OutTexcoords.tc_Store(addr + 3 * tc_Stride, asint(uv00));
					}
					else
					{
						OutTexcoords.tc_Store(addr + 0 * tc_Stride, asint(uv00));
						OutTexcoords.tc_Store(addr + 1 * tc_Stride, asint(uv11));
						OutTexcoords.tc_Store(addr + 2 * tc_Stride, asint(uv11));
						OutTexcoords.tc_Store(addr + 3 * tc_Stride, asint(uv00));
						OutTexcoords.tc_Store(addr + 4 * tc_Stride, asint(uv01));
						OutTexcoords.tc_Store(addr + 5 * tc_Stride, asint(uv10));
					}
				}

				if (OutputMask & MASK_OutTexcoord2s)
				{
					const uint		addr = vstart * tc_Stride;
					if (!is6vert)
					{
						OutTexcoord2s.tc_Store(addr + 0 * tc_Stride, asint(uv01_2));
						OutTexcoord2s.tc_Store(addr + 1 * tc_Stride, asint(uv11_2));
						OutTexcoord2s.tc_Store(addr + 2 * tc_Stride, asint(uv10_2));
						OutTexcoord2s.tc_Store(addr + 3 * tc_Stride, asint(uv00_2));
					}
					else
					{
						const uint		addr = vstart * tc_Stride;
						OutTexcoord2s.tc_Store(addr + 0 * tc_Stride, asint(uv00_2));
						OutTexcoord2s.tc_Store(addr + 1 * tc_Stride, asint(uv11_2));
						OutTexcoord2s.tc_Store(addr + 2 * tc_Stride, asint(uv11_2));
						OutTexcoord2s.tc_Store(addr + 3 * tc_Stride, asint(uv00_2));
						OutTexcoord2s.tc_Store(addr + 4 * tc_Stride, asint(uv01_2));
						OutTexcoord2s.tc_Store(addr + 5 * tc_Stride, asint(uv10_2));
					}
				}

				if (OutputMask & MASK_OutAtlasIDs)
				{
					//// 0-4
					//OutAtlasIDs.Store4(vstart * 4 + 0 * 4, asint((float4)softAnimBlend));
					//if (!is6vert)
					//{
					//	// 4-6
					//	OutAtlasIDs.Store2(vstart * 4 + 4 * 4, asint((float2)softAnimBlend));
					//}
					//else
					//{
					//	// 4-8
					//	OutAtlasIDs.Store4(vstart * 4 + 4 * 4, asint((float4)softAnimBlend));
					//	// 8-12
					//	OutAtlasIDs.Store4(vstart * 4 + 8 * 4, asint((float4)softAnimBlend));
					//}

					const uint		dynStride = 4;
					OutAtlasIDs.Store(vstart * dynStride + 0 * dynStride, asint(softAnimBlend));
					OutAtlasIDs.Store(vstart * dynStride + 1 * dynStride, asint(softAnimBlend));
					OutAtlasIDs.Store(vstart * dynStride + 2 * dynStride, asint(softAnimBlend));
					OutAtlasIDs.Store(vstart * dynStride + 3 * dynStride, asint(softAnimBlend));
					if (is6vert)
					{
						OutAtlasIDs.Store(vstart * dynStride + 4 * dynStride, asint(softAnimBlend));
						OutAtlasIDs.Store(vstart * dynStride + 5 * dynStride, asint(softAnimBlend));
					}
				}
			}

			const uint		istart = OutputIndexOffset + globali * (is6vert ? 12 : 6);
			uint			vertexi;
			if (InputMask & MASK_InIndices)
				vertexi = InIndices.Load((InIndicesOffset + globali) * 4);
			else
				vertexi = vstart;

			if (OutputMask & MASK_OutIndicesRaw)
			{
				OutIndicesRaw.Store(istart * 4 + 0 * 4, vertexi + 0);
				OutIndicesRaw.Store(istart * 4 + 1 * 4, vertexi + 1);
				OutIndicesRaw.Store(istart * 4 + 2 * 4, vertexi + 3);
				OutIndicesRaw.Store(istart * 4 + 3 * 4, vertexi + 1);
				OutIndicesRaw.Store(istart * 4 + 4 * 4, vertexi + 2);
				OutIndicesRaw.Store(istart * 4 + 5 * 4, vertexi + 3);
				if (is6vert)
				{
					OutIndicesRaw.Store(istart * 4 + 6 * 4, vertexi + 4);
					OutIndicesRaw.Store(istart * 4 + 7 * 4, vertexi + 3);
					OutIndicesRaw.Store(istart * 4 + 8 * 4, vertexi + 2);
					OutIndicesRaw.Store(istart * 4 + 9 * 4, vertexi + 1);
					OutIndicesRaw.Store(istart * 4 + 10 * 4, vertexi + 0);
					OutIndicesRaw.Store(istart * 4 + 11 * 4, vertexi + 5);
				}
			}
			if (OutputMask & MASK_OutIndices)
			{
				OutIndices[istart + 0] = vertexi + 0;
				OutIndices[istart + 1] = vertexi + 1;
				OutIndices[istart + 2] = vertexi + 3;
				OutIndices[istart + 3] = vertexi + 1;
				OutIndices[istart + 4] = vertexi + 2;
				OutIndices[istart + 5] = vertexi + 3;
				if (is6vert)
				{
					OutIndices[istart + 6  ] = vertexi + 4;
					OutIndices[istart + 7  ] = vertexi + 3;
					OutIndices[istart + 8  ] = vertexi + 2;
					OutIndices[istart + 9  ] = vertexi + 1;
					OutIndices[istart + 10 ] = vertexi + 0;
					OutIndices[istart + 11 ] = vertexi + 5;
				}
			}
		}
		else
		{
			// Store nothing
		}
	}
}

#endif // COMPILER_HLSL